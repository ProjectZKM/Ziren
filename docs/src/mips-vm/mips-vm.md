# MIPS VM
zkMIPS is a verifiable computation infrastructure based on the MIPS32, specifically designed to provide zero-knowledge proof generation for programs written in Rust and Golang. This enhances project auditing and the efficiency of security verification. Focusing on the extensive design experience of MIPS, zkMIPS adopts the MIPS32r2 instruction set as it offers significant hardware advantages. Compared to the RISC-V architecture, MIPS32r2 excels in several key features. Its J/JAL instructions support jump ranges of up to 256MiB, offering greater flexibility for large-scale data processing and complex control flow scenarios. Moreover, the rich set of bit manipulation instructions and additional conditional move instructions (such as MOVZ and MOVN) ensure precise data handling, while the inclusion of the MADDU instruction further improves arithmetic computation efficiency. Overall, by integrating mature MIPS design with zero-knowledge proof, zkMIPS provides an efficient and stable foundational platform for secure computing and decentralized applications.

**Execution Flow of zkMIPS**  
In the execution process of zkMIPS, a Rust program written by the developer is first transformed by a dedicated compiler into the MIPS instruction set, generating a corresponding ELF binary file. This process accurately maps the high-level logic of the program to low-level instructions, laying a solid foundation for subsequent verification. Next, the system employs a specially designed executor to simulate the execution of the ELF file, recording all state changes and computational steps to form a complete execution record with different type of [events](https://github.com/zkMIPS/zkm/tree/dev/init/crates/core/executor/src/events). The events will then be used to generate different traces for different chips. This traces serve as the core data for generating the zero-knowledge proof, ensuring that the proof accurately reflects the real execution of the compiled program. Subsequently, the zkMIPS prover efficiently processes and compresses the generated trace to produce a zero-knowledge proof. This proof not only validates the correctness of the program execution but also significantly reduces the data volume, facilitating rapid verification and storage. Finally, the generated proof is jointly verified by multiple participants and ultimately recorded on-chain, ensuring that the entire computational process is transparent, secure, and trustworthy. With the nice property of zkSNARK, the proof is short and fast to verify.

**Circuit Module of zkMIPS**  
In terms of circuit design, zkMIPS adopts a highly modular strategy, breaking the entire MIPS program into multiple submodules with clearly defined functions to meticulously manage and verify the execution state of each part. The system can be divided into several modules: CPU, memory, byte processing,  and instructions. 

***The CPU module*** focuses on common operation for all instructions， such as register read/write， pc and shard processing, .etc. 

***The memory module*** clearly distinguishes between global and local memory, establishing defined boundaries for data access and state transfer. 

***byte processing modules*** are employed to manage byte data validation and processing.

***instructions modules*** focuses on computation for different type of instructions. It can be divided into different type of sub-chips (ALU, Branch, Jump, Memory, Syscall, Misc). Each chip focuses on one kind or type of instructions. Such as ALU chip focuses on arithmetic and logical computations, supporting various specific operations including instructions like CLO/Z. Branch chip focuses on conditional branch.

Through this detailed division of circuit modules, zkMIPS can accurately capture the behavior and state of each submodule during the generation of the zero-knowledge proof, to improve the overall security of the system.
