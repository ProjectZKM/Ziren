# Prover

The zkm_sdk crate provides all the necessary tools for proof generation. Key features include the `ProverClient`, enabling you to:
- Initialize proving/verifying keys via `setup()`. 
- Execute your program via `execute()`.
- Generate proofs with `prove()`.
- Verify proofs through `verify()`.

## Example: [Fibonacci](https://github.com/zkMIPS/zkm/blob/dev/init/examples/fibonacci/host/src/main.rs)

The following code is a example of using zkm_sdk in host.

```rust
use zkm_sdk::{include_elf, utils, ProverClient, ZKMProofWithPublicValues, ZKMStdin};

/// The ELF we want to execute inside the zkVM.
const ELF: &[u8] = include_elf!("fibonacci");

fn main() {
    // Create an input stream and write '1000' to it.
    let n = 1000u32;

    // The input stream that the guest will read from using `zkm_zkvm::io::read`. Note that the
    // types of the elements in the input stream must match the types being read in the program.
    let mut stdin = ZKMStdin::new();
    stdin.write(&n);

    // Create a `ProverClient` method.
    let client = ProverClient::new();

    // Execute the guest using the `ProverClient.execute` method, without generating a proof.
    let (_, report) = client.execute(ELF, stdin.clone()).run().unwrap();
    println!("executed program with {} cycles", report.total_instruction_count());

    // Generate the proof for the given program and input.
    let (pk, vk) = client.setup(ELF);
    let mut proof = client.prove(&pk, stdin).run().unwrap();

    // Read and verify the output.
    //
    // Note that this output is read from values committed to in the program using
    // `zkm_zkvm::io::commit`.
    let n = proof.public_values.read::<u32>();
    let a = proof.public_values.read::<u32>();
    let b = proof.public_values.read::<u32>();

    println!("n: {}", n);
    println!("a: {}", a);
    println!("b: {}", b);

    // Verify proof and public values
    client.verify(&proof, &vk).expect("verification failed");
}
```

## Proof Types

zkMIPS<sup>+</sup> provides customizable proof generation options:

```rust
/// A proof generated with zkMIPS of a particular proof mode.
#[derive(Debug, Clone, Serialize, Deserialize, EnumDiscriminants, EnumTryAs)]
#[strum_discriminants(derive(Default, Hash, PartialOrd, Ord))]
#[strum_discriminants(name(ZKMProofKind))]
pub enum ZKMProof {
    /// A proof generated by the core proof mode.
    ///
    /// The proof size scales linearly with the number of cycles.
    #[strum_discriminants(default)]
    Core(Vec<ShardProof<CoreSC>>),
    /// A proof generated by the compress proof mode.
    ///
    /// The proof size is constant, regardless of the number of cycles.
    Compressed(Box<ZKMReduceProof<InnerSC>>),
    /// A proof generated by the Plonk proof mode.
    Plonk(PlonkBn254Proof),
    /// A proof generated by the Groth16 proof mode.
    Groth16(Groth16Bn254Proof),
}
```

### [Core Proof (Default)](https://github.com/zkMIPS/zkm/blob/dev/init/examples/fibonacci/host/src/main.rs)

The default prover mode generates a sequence of STARK proofs whose cumulative proof size scales linearly with the execution trace length.

```rust
let client = ProverClient::new();
client.prove(&pk, stdin).run().unwrap();
```

### [Compressed Proof](https://github.com/zkMIPS/zkm/blob/dev/init/examples/fibonacci/host/bin/compressed.rs)

The compressed proving mode generates constant-sized STARK proofs, but not suitable for on-chain verification.

```rust
let client = ProverClient::new();
client.prove(&pk, stdin).compressed().run().unwrap();
```

### [Groth16 Proof (Recommended)](https://github.com/zkMIPS/zkm/blob/dev/init/examples/fibonacci/host/bin/groth16_bn254.rs)

The Groth16 proving mode ​generates succinct SNARK proofs with a compact size of approximately 260 bytes, ​and features on-chain verification.

```rust
let client = ProverClient::new();
client.prove(&pk, stdin).groth16().run().unwrap();
```

### [PLONK Proof](https://github.com/zkMIPS/zkm/blob/dev/init/examples/fibonacci/host/bin/plonk_bn254.rs)

The PLONK proving mode generates succinct SNARK proofs with a compact size of approximately 868 bytes, while maintaining on-chain verifiability. In contrast to Groth16, PLONK removes the dependency on trusted setup ceremonies.

```rust
let client = ProverClient::new();
client.prove(&pk, stdin).plonk().run().unwrap();
```

## Hardware Acceleration

zkMIPS provides hardware acceleration support for [`AVX256/AVX512`](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) on x86 CPUs due to support in [`Plonky3`](https://github.com/Plonky3/Plonky3).

You can check your CPU's AVX compatibility by running:

```shell
grep avx /proc/cpuinfo
```

Check if you can see `avx2` or `avx512` in the results.

To activate **AVX256** optimization, add these flags to your RUSTFLAGS environment variable:

```shell
RUSTFLAGS="-C target-cpu=native" cargo run --release
```

To activate **AVX512** optimization, add these flags to your RUSTFLAGS environment variable:

```shell
RUSTFLAGS="-C target-cpu=native -C target-feature=+avx512f" cargo run --release
```
